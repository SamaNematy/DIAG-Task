# -*- coding: utf-8 -*-
"""Task_1 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OeEzrM_vSbQpCQtjPmKl_bDBIATw7YUx
"""


import numpy as np
import matplotlib.pyplot as plt
from skimage import io, color
import scipy.signal
import cv2

# Commented out IPython magic to ensure Python compatibility.
# %cd "/content/drive/MyDrive/Colab Notebooks/Task_1"

# Load the noisy "office" image
image = cv2.imread('office_noisy.png', cv2.IMREAD_GRAYSCALE)

# Function to apply Gaussian smoothing
def gaussian_smoothing(image, sigma):
    # Apply Gaussian blur with automatic kernel size
    result = cv2.GaussianBlur(image, (0, 0), sigma)
    
    # Calculate the kernel size based on sigma
    ksize = 2 * int(3 * sigma) + 1
    print(f"Sigma: {sigma}, Kernel Size: {ksize}x{ksize}")
    
    return result

# List of sigma values
sigma_values = [0.5, 1, 2, 5, 10, 50]

# Apply Gaussian smoothing for each sigma value and store the results
smoothed_images = [gaussian_smoothing(image, sigma) for sigma in sigma_values]

# Display the original and smoothed images
plt.imshow(image, cmap='gray')
plt.title('Original Noisy Image')
plt.axis('off')

for i, (sigma, smoothed) in enumerate(zip(sigma_values, smoothed_images)):
    plt.imshow(smoothed, cmap='gray')
    plt.title(f'Gaussian Smoothing\nσ = {sigma}')
    plt.axis('off')
    plt.tight_layout()
    plt.show()


# Define the large sigma and small kernel size
kernel_size = 3
sigma_1 = (kernel_size - 1) / 6  # Most effective sigma value based on kernel size
sigmas = [sigma_1, 10 * sigma_1, 100 * sigma_1, 100000 * sigma_1, 10]

# Apply Gaussian blurring and store results
blurred_images = [cv2.GaussianBlur(image, (kernel_size, kernel_size), sigma) for sigma in sigmas]

# Plot original and blurred images
plt.figure(figsize=(15, 5))  # Adjust the figure size if needed

# Show original image
plt.subplot(1, 6, 1)
plt.title('Original Image', fontsize=9)
plt.imshow(image, cmap='gray')
plt.axis('off')

# Show blurred images
for i, (blurred_image, sigma) in enumerate(zip(blurred_images, sigmas)):
    plt.subplot(1, 6, i + 2)
    plt.title(f'Kernel Size: {kernel_size}x{kernel_size}, Sigma: {sigma:.2f}', fontsize=9)
    plt.imshow(blurred_image, cmap='gray')
    plt.axis('off')

plt.show()


def linear_diffusion(image, d, time_step, num_iterations):
    img = image.astype(np.float32)
    for _ in range(num_iterations):
        laplacian = cv2.Laplacian(img, cv2.CV_32F)
        img += d * time_step * laplacian
    return img

# Load noisy image
noisy_image = cv2.imread('office_noisy.png', cv2.IMREAD_GRAYSCALE)

# Parameters
d = 1.0  # diffusivity
time_steps = [1, 5, 10, 30, 100]
boundary_conditions = 'Neumann'  # Zero-flux boundary conditions

# Apply linear diffusion smoothing for different time steps
results = []
for t in time_steps:
    num_iterations = int(t / 0.1)  # Adjust the number of iterations based on time step
    smoothed_image = linear_diffusion(noisy_image, d, 0.1, num_iterations)
    results.append(smoothed_image)

# Display results
plt.imshow(noisy_image, cmap='gray'), plt.title('Noisy Image')
plt.axis('off')
plt.tight_layout()
plt.show()
for i, t in enumerate(time_steps):
    plt.imshow(results[i], cmap='gray'), plt.title(f't = {t}')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

# Parameters
d = 1.0  # diffusivity
t = 10  # total diffusion time

# Apply linear diffusion smoothing for different time steps
time_steps = [1, 0.5, 0.1]  # Different time steps to compare
results = []

for delta_t in time_steps:
    num_iterations = int(t / delta_t)
    smoothed_image = linear_diffusion(noisy_image, d, delta_t, num_iterations)
    results.append((delta_t, smoothed_image))

# Display results
plt.imshow(noisy_image, cmap='gray'), plt.title('Noisy Image')

for i, (delta_t, img) in enumerate(results):
    plt.imshow(img, cmap='gray'), plt.title(f'Δt = {delta_t}, t = {t}')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

def linear_diffusion(image, d, time_step, num_iterations):
    img = image.astype(np.float32)
    for _ in range(num_iterations):
        laplacian = cv2.Laplacian(img, cv2.CV_32F)
        img += d * time_step * laplacian
        # Clamp values to prevent overflow
        img = np.clip(img, 0, 255)
    return img

# Load noisy image
noisy_image = cv2.imread('office_noisy.png', cv2.IMREAD_GRAYSCALE)

# Parameters
t = 10  # total diffusion time
delta_t = 0.01  # smaller time step to improve stability

# Diffusivity values to test
diffusivities = [1, 5, 10]

# Apply linear diffusion smoothing for different diffusivity values
results = []

for d in diffusivities:
    num_iterations = int(t / delta_t)
    smoothed_image = linear_diffusion(noisy_image, d, delta_t, num_iterations)
    results.append((d, smoothed_image))

# Display results
plt.imshow(noisy_image, cmap='gray'), plt.title('Original Noisy Image')
plt.axis('off')
plt.tight_layout()
plt.show()
for i, (d, img) in enumerate(results):
    plt.imshow(img, cmap='gray'), plt.title(f'd = {d}, t = {t}')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

def linear_diffusion(image, d, time_step, num_iterations):
    img = image.astype(np.float32)
    for _ in range(num_iterations):
        laplacian = cv2.Laplacian(img, cv2.CV_32F)
        img += d * time_step * laplacian
        # Clamp values to prevent overflow
        img = np.clip(img, 0, 255)
    return img

# Load noisy image
noisy_image = cv2.imread('office_noisy.png', cv2.IMREAD_GRAYSCALE)

# Parameters
t = 10  # total diffusion time
delta_t = 0.01  # smaller time step to improve stability
d = 1  # diffusivity

# Perform linear diffusion smoothing
num_iterations = int(t / delta_t)
diffused_image = linear_diffusion(noisy_image, d, delta_t, num_iterations)

# Perform Gaussian smoothing
sigma = np.sqrt(2 * t)
gaussian_smoothed_image = cv2.GaussianBlur(noisy_image, (0, 0), sigma)

# Display results
plt.imshow(noisy_image, cmap='gray'), plt.title('Noisy Image')
plt.axis('off')
plt.tight_layout()
plt.show()
plt.imshow(diffused_image, cmap='gray'), plt.title(f'Linear Diffusion (t={t})')
plt.axis('off')
plt.tight_layout()
plt.show()
plt.imshow(gaussian_smoothed_image, cmap='gray'), plt.title(f'Gaussian Smoothing (σ={sigma:.2f})')
plt.axis('off')
plt.tight_layout()
plt.show()

def nonlinearDiffusionFilter(image: np.ndarray, iterations=10, lamb=1.0, tau=0.125):
    def computeUpdate(u: np.ndarray, g: np.ndarray):
        update = np.zeros(u.shape, dtype=float)
        u = np.pad(u, pad_width=1, mode='reflect')
        g = np.pad(g, pad_width=1, mode='reflect')

        for i in range(1, u.shape[1] - 1):
            for j in range(1, u.shape[0] - 1):
                g_pj = np.sqrt(g[j, i + 1] * g[j, i])
                g_nj = np.sqrt(g[j, i - 1] * g[j, i])
                g_ip = np.sqrt(g[j + 1, i] * g[j, i])
                g_in = np.sqrt(g[j - 1, 1] * g[j, i])

                ux0 = g_pj * (u[j, i + 1] - u[j, i])
                ux1 = -g_nj * (u[j, i] - u[j, i - 1])
                uy0 = g_ip * (u[j + 1, i] - u[j, i])
                uy1 = -g_in * (u[j, i] - u[j - 1, i])

                update[j - 1, i - 1] = ux0 + ux1 + uy0 + uy1

        return update

    def computeDiffusivity(u: np.ndarray, lamb: float):
        gradkernelx = 0.5 * np.array([[0.0, 0.0, 0.0], [-1.0, 0.0, 1.0], [0.0, 0.0, 0.0]])
        gradkernely = 0.5 * np.array([[0.0, -1.0, 0.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]])
        gradx = scipy.signal.convolve2d(u, gradkernelx, boundary='symm', mode='same')
        grady = scipy.signal.convolve2d(u, gradkernely, boundary='symm', mode='same')
        gradm2 = np.power(gradx, 2) + np.power(grady, 2)
        g = 1.0 / np.sqrt(1.0 + gradm2 / (lamb * lamb))
        return g

    u = np.copy(image)
    if len(u.shape) > 2:
        u = u[:, :, 0]  # Convert to grayscale if it is an RGB image

    for i in range(iterations):
        g = computeDiffusivity(u, lamb)
        update = computeUpdate(u, g)
        u = u + tau * update

    return u

# Load the noisy "office" image
noisy_image = io.imread('office_noisy.png')
if noisy_image.ndim == 3:
    noisy_image = color.rgb2gray(noisy_image)

# Parameters
diffusion_times = [1, 5, 10, 30, 100]
lambda_value = 0.5

# Perform diffusion for different times
results = []
for t in diffusion_times:
    iterations = int(t / 0.125)  # t / tau, with tau = 0.125
    result = nonlinearDiffusionFilter(noisy_image, iterations=iterations, lamb=lambda_value, tau=0.125)
    results.append(result)

# Plot the results
for i, (t, result) in enumerate(zip(diffusion_times, results)):
    plt.imshow(result, cmap='gray')
    plt.title(f'Diffusion Time: {t}')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

# Parameters
lambdas = [0.5, 1, 2, 5, 10]
time_t = 10
iterations = int(time_t / 0.125)  # t / tau, with tau = 0.125

# Perform diffusion for different lambda values
lambda_results = []
for lamb in lambdas:
    result = nonlinearDiffusionFilter(noisy_image, iterations=iterations, lamb=lamb, tau=0.125)
    lambda_results.append(result)

# Plot the results
for i, (lamb, result) in enumerate(zip(lambdas, lambda_results)):
    plt.imshow(result, cmap='gray')
    plt.title(f'lambda: {lamb}')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

# Load the clean "office" image
clean_image = io.imread('office.png')
if clean_image.ndim == 3:
    clean_image = color.rgb2gray(clean_image)

# Parameters
diffusion_times = [1, 5, 10, 30, 100]
lambda_value = 0.5

# Perform diffusion on clean image to compute diffusivity
g_clean = nonlinearDiffusionFilter(clean_image, iterations=1, lamb=lambda_value, tau=0.125)

# Plot the clean image diffusivity
plt.figure(figsize=(5, 5))
plt.imshow(g_clean, cmap='gray')
plt.title('Diffusivity of Clean Image')
plt.axis('off')
plt.tight_layout()
plt.show()
